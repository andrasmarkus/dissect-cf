/*
 *  ========================================================================
 *  DIScrete event baSed Energy Consumption simulaTor 
 *    					             for Clouds and Federations (DISSECT-CF)
 *  ========================================================================
 *  
 *  This file is part of DISSECT-CF.
 *  
 *  DISSECT-CF is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or (at
 *  your option) any later version.
 *  
 *  DISSECT-CF is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser
 *  General Public License for more details.
 *  
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with DISSECT-CF.  If not, see <http://www.gnu.org/licenses/>.
 *  
 *  (C) Copyright 2019, Andras Markus (markusa@inf.u-szeged.hu)
 */

package hu.uszeged.inf.iot.simulator.entities;

import java.util.EnumMap;
import java.util.HashMap;
import java.util.Map;

import javax.xml.bind.JAXBException;

import hu.mta.sztaki.lpds.cloud.simulator.Timed;
import hu.mta.sztaki.lpds.cloud.simulator.energy.powermodelling.PowerState;
import hu.mta.sztaki.lpds.cloud.simulator.io.NetworkNode;
import hu.mta.sztaki.lpds.cloud.simulator.io.NetworkNode.NetworkException;
import hu.mta.sztaki.lpds.cloud.simulator.io.Repository;
import hu.mta.sztaki.lpds.cloud.simulator.util.PowerTransitionGenerator;
import hu.uszeged.inf.iot.simulator.fog.Application;
import hu.uszeged.inf.xml.model.DeviceModel;

/**
 * This is an abstract super class for the possibility of modeling IoT sensors. 
 * The main task of this class to create a local storage (otherwise Repository) where the 
 * generated data (by sensors) are stored.
 * @author Andras Markus (markusa@inf.u-szeged.hu)
 */
public abstract class Device extends Timed {
		
	/**
	 * It's a unchangeable value for the network connection of the local storage. 
	 */
	protected static final int LATENCY=11;
	
	/**
	 * Stores a storage-latency pair. Repositories can communicate only if their latencies are equal.
	 */
	protected static HashMap<String, Integer> lmap = new HashMap<String, Integer>();
	
	/**
	 * It's a reference for the application which processes the data generated by a device.
	 */
	protected Application app;
	
	/**
	 * The local repository can be reached through this variable.
	 */
	protected DeviceNetwork dn;
	
	/**
	 * Contains the amount of generated data by the sensors of this device.
	 */
	private long sumOfGeneratedData;
	
	/**
	 * A counter for the all of generated files by the sensors of this device.
	 */
	protected int messageCount;
	
	/**
	 * A reference for the destination repository of the generated data.
	 */
	protected Repository cloudRepository;
	
	/**
	 *	The simulated time when the device starts the data generation-sending loops.
	 */
	protected long startTime;
	
	/**
	 *	The simulated time when the device stops the data generation-sending loops.
	 */
	protected long stopTime;
	
	/**
	 *	The size of the generated data (e.g. in byte).
	 */
	protected long filesize;
	
	/**
	 * This method performs the shutdown-restart process. 
	 * TODO: not implemented yet.
	 */
	protected abstract void shutdownProcess();
	
	/**
	 * Load the defined devices in XML file, useful for in case of numerous devices.
	 * @param file The path of the XML file.
	 */
	public static void loadDevice(String file){
		try {
			for(DeviceModel dm : DeviceModel.loadDeviceXML(file)) {
				for(int i=0;i<dm.number;i++){
					DeviceNetwork dn = new DeviceNetwork(dm.maxinbw,dm.maxoutbw,dm.diskbw,dm.reposize,dm.name+i,null,null);
					new Station(dn,dm.starttime,dm.stoptime,dm.filesize,dm.strategy,dm.sensor,dm.freq,true);
				}
				
			}
		} catch (JAXBException e) {
			e.printStackTrace();
		}
	}
	
	/**
	 * This class represents the communicating and storing entity called Repository where the generated data are stored.
	 * 
	 */
	public static class DeviceNetwork {
		
		/**
		 * Reference for the local repository of the device.
		 */
		private Repository localRepository;
		  			  
		/**
		 * Getter for the local repository of the device.
		 */
		public Repository getLocalRepository() {
			return localRepository;
		}

		/**
		 * The constructor generate the local repository of the device. Leave the last 2 parameters to
		 * null for using the default storage and network transitions.
		 * @param maxinbw The maximum value of the input bandwidth (e.g. in byte).
		 * @param maxoutbw The maximum value of the output bandwidth (e.g. in byte).
		 * @param diskbw The bandwidth between disks in byte.
		 * @param repoSize The maximum size of the local repository (e.g. in byte).
		 * @param repoName The ID of the repository.
		 * @param storageTransitions Storage power behavior, leave it to null for the default value
		 * @param networkTransitions Network power behavior, leave it to null for the default value
		 */
		public DeviceNetwork(long maxinbw, long maxoutbw, long diskbw, long repoSize,String repoName,Map<String, PowerState> storageTransitions,Map<String, PowerState> networkTransitions) {
			if(storageTransitions==null) {
				storageTransitions=defaultStorageTransitions();
			}
			if(networkTransitions==null) {
				networkTransitions=defaultNetworkTransitions();
			}
			localRepository = new Repository(repoSize, repoName, maxinbw, maxoutbw, diskbw, lmap, storageTransitions, networkTransitions);
			try {
				localRepository.setState(NetworkNode.State.RUNNING);
			} catch (NetworkException e) {
				e.printStackTrace();
			}	
		}
		
	}
	
	/**
	 * Getter for the simulated time when the device stops the data generation-sending loops.
	 */
	public long getStopTime() {
		return stopTime;
	}

	/**
	 * Getter for the size of the generated data (e.g. in byte).
	 */
	public long getFilesize() {
		return filesize;
	}

	/**
	 * Getter for the local repository.
	 */
	public DeviceNetwork getDn() {
		return dn;
	}

	/**
	 * Getter for a counter for the all of generated files by the sensors of this device.
	 */
	public int getMessageCount() {
		return messageCount;
	}

	/**
	 * Setter for a counter for the all of generated files by the sensors of this device.
	 */
	public void setMessageCount(int messageCount) {
		this.messageCount = messageCount;
	}
	
	/**
	 * Getter for the amount of generated data by the sensors of this device.
	 */
	public long getSumOfGeneratedData() {
		return sumOfGeneratedData;
	}

	/**
	 * Setter for the amount of generated data by the sensors of this device.
	 */
	public void setSumOfGeneratedData(long sumOfGeneratedData) {
		this.sumOfGeneratedData = sumOfGeneratedData;
	}
	
	/**
	 * Setter for the application which process the data generated by a device.
	 */
	public void setApp(Application app) {
		this.app = app;
	}
	
	/**
	 * Default representative storage power behavior.
	 */
	private static Map<String, PowerState> defaultStorageTransitions(){
		double minpower = 20;
		double idlepower = 200;
		double maxpower = 300;
		double diskDivider = 10;
		double netDivider = 20;
		EnumMap<PowerTransitionGenerator.PowerStateKind, Map<String, PowerState>> transitions = null;
		try {
			transitions = PowerTransitionGenerator
					.generateTransitions(minpower, idlepower, maxpower, diskDivider, netDivider);
		} catch (SecurityException e) {
			e.printStackTrace();
		} catch (InstantiationException e) {
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		} catch (NoSuchFieldException e) {
			e.printStackTrace();
		}
		return transitions.get(PowerTransitionGenerator.PowerStateKind.storage);
	}

	/**
	 * Default representative network power behavior.
	 */
	private static Map<String, PowerState> defaultNetworkTransitions(){
		double minpower = 20;
		double idlepower = 200;
		double maxpower = 300;
		double diskDivider = 10;
		double netDivider = 20;
		EnumMap<PowerTransitionGenerator.PowerStateKind, Map<String, PowerState>> transitions = null;
		try {
			transitions = PowerTransitionGenerator
					.generateTransitions(minpower, idlepower, maxpower, diskDivider, netDivider);
		} catch (SecurityException e) {
			e.printStackTrace();
		} catch (InstantiationException e) {
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		} catch (NoSuchFieldException e) {
			e.printStackTrace();
		}
		return transitions.get(PowerTransitionGenerator.PowerStateKind.network);
	}

}
